#include <iostream>
#include <cstdlib>
#include <algorithm>
#include "VNS.hpp"
#include <limits> 

using namespace std;

VNS::VNS(Instance* inst) {
   m_instance = inst;	
}


VNS::~VNS(){
   // empty
}

void VNS::run(const bool verbose) {
   
   // generate constructive initial solution (Time-Oriented Nearest Neighbor)
   Solution s = tonn();

   // apply a descent on the move-customer-opt neighborhood
   int iterations = 0;
   bool local_minimum = false;
   do {
   		s = moveCustomerOpt(s,local_minimum);
   		iterations++;
   } while (!local_minimum);

   cout << "Iterations: " << iterations << endl;
   
   // unsigned n = 0, n_max = 2;
   // do {
   //    // Shake; Generate a point s' at random from the nth neighborhood of s
   //    // LocalSearch; Apply LS with s' as initial solution. Obtain s''.
   //    // Acceptance; If this is a local optimum, then s = s'', n = 0. Else n++.
   // } while (n < n_max);

   if (verbose) {
      s.print();
   }
   cout << "Total dist: " << s.getTotalDist() << endl;
   cout << "Vehicles used: " << s.getVehiclesUsed() << endl;
}

/*
	Implements the Time-Oriented Nearest Neighbor Heuristic (TONN)
	* starts at the first route
	* starting at the depot, searches for the nearest feasible customer to add to the current route
	* if there is no such customer, proceed to the next route
*/
Solution VNS::tonn() {
   Solution s(m_instance);
   
   unsigned unroutedCount = m_instance->getCustomers();
   vector<char> unrouted(unroutedCount+1, 1); // 1 if customer is unrouted, 0 otherwise
   unrouted[0] = 0;

   unsigned currentRoute = 0;
   unsigned previousCustomer = 0;
   while (unroutedCount > 0) {
   	// initialize "nearest" with the maximum value for double variables
      double nearest = std::numeric_limits<double>::max();
      unsigned nearestIndex = 0;
      
      for (unsigned i = 1; i <= m_instance->getCustomers(); i++) {
         if (unrouted[i] && m_instance->getDistance(previousCustomer, i) < nearest) {
            // Check feasibility (capacity and time-window)
            if (s.getRouteLoad(currentRoute) + m_instance->getDemand(i) <= m_instance->getCapacity()
             && s.getCustomerTime(previousCustomer) + m_instance->getDistance(previousCustomer, i) /*+ m_instance->getService(i)*/ <= m_instance->getEtw(i)) {
               	nearest = m_instance->getDistance(previousCustomer, i);
               	nearestIndex = i;
            }
         }
      }

      // Add nearest feasible customer to route
      if (nearestIndex > 0) {
         // cout << "Added " << nearestIndex << " to route " << currentRoute << endl;
         s.addToRoute(previousCustomer, nearestIndex, currentRoute);
         unroutedCount--;
         unrouted[nearestIndex] = 0;
         previousCustomer = nearestIndex;         
      }
      else { // Add new route if there isn't any feasible insertion
         // cout << "Created new route" << endl;
         currentRoute++;
         previousCustomer = 0;
      }
   }

   return s;
}

/*
	Implements the Relaxed version of the Time-Oriented Nearest Neighbor Heuristic (RTONN)
	* input: 		an incomplete route (that does not service all customers) generated by TONN
	* output: 		an infeasible route (breaking time-window constraints) that services all customers 
	* operation: 	repeatedly adds the overall nearest neighbor (all routes considered) to its respective route
*/
Solution VNS::rtonn(Solution s){
	
	unsigned unroutedCount = m_instance->getCustomers();
	vector<char> unrouted(unroutedCount+1, 1); // 1 if customer is unrouted, 0 otherwise
	unrouted[0] = 0;

	// lastCustomer[k] : the current last customer in the k-th route
	vector<unsigned> lastCustomer(s.getVehiclesUsed(),-1);

	// for each route k
	for(unsigned k = 0; k < s.getVehiclesUsed(); k++) {
		// for each customer in the k-th route
		unsigned cust = 0;
		for(unsigned i = 1; i < s.getRouteSize(k); i++) {
			cust = s.getSuccessor(cust,k);
			// mark 'cust' as routed and decrement the unrouted customers count
			unrouted[cust] = 0;
			unroutedCount--;

			if(i == s.getRouteSize(k)-1){
				lastCustomer[k] = cust;
			}
		}
	}

	// while there are unrouted customers
	while (unroutedCount > 0) {
   	  // initialize "nearest" with the maximum value for double variables
      double nearest = std::numeric_limits<double>::max();
      unsigned nearestIndex = -1;
      unsigned routeIndex = -1;

      // for each route k
      for(unsigned k = 0; k < s.getVehiclesUsed(); k++) {
      	// for each customer
      	for(unsigned i = 1; i <= m_instance->getCustomers(); i++){
      		// if client is unrouted and the current nearest neighbor among all routes
      		if (unrouted[i] && m_instance->getDistance(lastCustomer[k], i) < nearest) {
      			nearest = m_instance->getDistance(lastCustomer[k], i);
	            nearestIndex = i;
	            routeIndex = k;
      		}
      	}
      }

      // Add nearest feasible customer to route
      s.addToRoute(lastCustomer[routeIndex], nearestIndex, routeIndex);
      unroutedCount--;
      unrouted[nearestIndex] = 0;
      lastCustomer[routeIndex] = nearestIndex;
   }

   return s;
}


Solution VNS::twoOpt(Solution s, const unsigned k) {
   unsigned ci  = 0;
   do {
      unsigned cii = s.getSuccessor(ci, k);
      unsigned cj  = s.getSuccessor(cii, k);
      while (cii != 0 && cj != 0) {
         unsigned cjj = s.getSuccessor(cj, k);

         double delta = m_instance->getDistance(ci, cj)  + m_instance->getDistance(cii, cjj)
                      - m_instance->getDistance(ci, cii) - m_instance->getDistance(cj, cjj);


         // If the new route is shorter
         if (delta < 0) {
         	// Check feasibility
         	bool feasible = true;
            // Starting from the depot, check the time window of each customer 'c' in the k-th route
            unsigned c = 0;
            // Let 'at' denote the arrival time at the current customer
            unsigned at = 0;
            for(int i = 0; i < s.getRouteSize(k); i++) {
            	// Let 'sc' denote the successor of customer 'c'
            	unsigned sc;

            	// If 'c' is one of the following customers: ci, cj, cii or cjj, we must:
            	// 1. manually enter its successor 'sc' and
            	// 2. if 'c' is one of the following customers: ci, cjj: reverse the route's orientation
            	switch(c) {
            		case ci:
            			if(succ) 	sc = cj;
            			else 		sc = m_instance->getPredecessor(c,k);
            			break;
            		case cj:
            			if(succ) 	{ sc = ci; succ = false; }
            			else 		sc = m_instance->getPredecessor(c,k);
            			break;
            		case cii:
            			sc = cjj;
            			break;
            		case cjj:
            			sc = m_instance->getSuccessor(c,k);
            			succ = false;
            			break;
            	}

            	m_instance->getSuccessor(c,k);

            	// Update the arrival time
            	at = max(at + m_instance->getDistance(c,sc) + m_instance.getService(sc), m_instance->getBtw(sc));

            	// Check if end time window is violated
            	if (at > m_instance->getEtw(sc)) {
            		feasible = false;
            		break;
            	}

            	// Update the current customer
            	c = sc;
            }

            if(feasible) {
            	s.remFromRoute();
            }
         }

         cj = cjj;
      }

      ci = cii;

   } while (ci != 0);

   return s;
}

/*Solution VNS::twoOpt(Solution s, const unsigned k) {
   unsigned ci  = 0;
   do {
      unsigned cii = s.getSuccessor(ci, k);
      unsigned cj  = s.getSuccessor(cii, k);
      while (cii != 0 && cj != 0) {
         unsigned cjj = s.getSuccessor(cj, k);

         double delta = m_instance->getDistance(ci, cj)  + m_instance->getDistance(cii, cjj)
                      - m_instance->getDistance(ci, cii) - m_instance->getDistance(cj, cjj);

         // If the new route is shorter
         if (delta < 0) {
            // Check feasibility
            // From ci to the end of the route, verify each time window
            unsigned c = ci;
            do {
               // unsigned tcj = m_instance->getService(cj) + max((double)m_instance->getBtw(cj), (s.getCustomerTime(ci) + m_instance->getDistance(ci, cj)));
               c = s.getSuccessor(c, k);
            } while (c != 0);
         }

         cj = cjj;
      }

      ci = cii;
   } while (ci != 0);

   return s;
}*/

/*
	Implements a local search on the "move-customer" inter-route neighborhood
	* the move-customer neighborhood of S is defined as the set of solutions S' generated by removing one customer of its respective route and inserting it into another one
*/
Solution VNS::moveCustomerOpt(Solution s, bool& local_minimum){

	// shuffle the order in which customers are to be traversed in order to randomize the search
	vector<unsigned> shuffledCustomers(m_instance->getCustomers(),0);
	for(unsigned i = 0; i < m_instance->getCustomers(); i++){
		shuffledCustomers[i] = i+1;
	}
	random_shuffle(shuffledCustomers.begin(),shuffledCustomers.end());

	// for each customer 'i'
	for(unsigned i : shuffledCustomers){
		
		// get the route 'ki' to which customer 'i' belongs
		unsigned ki = s.getCustomerRoute(i);

		// for each other customer 'j' (including depot)
		for(unsigned j : shuffledCustomers){
			// get the route 'kj' to which customer 'j' belongs
			unsigned kj = s.getCustomerRoute(j);
			if(i != j && ki != kj){
				// check feasibility (capacity and time-window)
				if(s.getRouteLoad(kj) + m_instance->getDemand(i) <= m_instance->getCapacity()
					&& s.getCustomerTime(j) + m_instance->getDistance(j,i) <= m_instance->getEtw(i)){
					
					// d1: the cost of removing customer 'i' from route 'ki'
					double d1 = - m_instance->getDistance(s.getPredecessor(i,ki),i) - m_instance->getDistance(i,s.getSuccessor(i,ki)) + m_instance->getDistance(s.getPredecessor(i,ki),s.getSuccessor(i,ki));

					// d2: the cost of adding customer 'i' to route 'kj'
					double d2 = - m_instance->getDistance(j,s.getSuccessor(j,kj)) + m_instance->getDistance(j,i) + m_instance->getDistance(i,s.getSuccessor(j,kj));

					// check if current neighbor has a better cost
					if( d1 + d2 < 0 ){
						s.remFromRoute(s.getPredecessor(i,ki),i,ki);
						s.addToRoute(j,i,kj);
						local_minimum = false;
						return s;
					}
				}

			}
		}
	}

	/* a local minimum has been reached */
	local_minimum = true;
	return s;
}